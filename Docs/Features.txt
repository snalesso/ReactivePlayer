FUNCTIONALITIES:
- get inspired: http://www.foobar2000.org/components
- when a file change/move is detected listen to the preview to check if the tags correspond to the file data: http://opensource.wildgums.com/orc.filesystem/
- add speakers/headphones and more generically "playback device selection"
- save to 2nd file (in %temp%, plus for coincidental SSD speed), and replace the current one at the end in order to prevent data loss
- white noise generator
- adjustable playback gap (gapless supported, settings to automatically disable gap when playing a full album, in native order)
- total time played calculator
- refresh tags
- dislike (bool? true/null/false) and/or some sort of "this tracks is in library for collection, but I don't want to ever listen to it if not manually"
- audio editor (cut, insert silence, etc.)
✔ taskbar playback progress
- screensaver
- aquire lock on file when edit tags UI is opened
- waveform seekbar
- distinguish special album versions (e.g. Deluxe, ...)
- restore last playing track & position
- play + enter -> play selection and switch to mini player
- play single track without enqueueing entire tracks list
- skip &
	- remove from playlist
	- remove from library
	- move to bin
- if the currently playing track is removed from the playlist from which its playback was started, ask if stop playback
- library level tracks bin (moves to recycle bin on app close?)
- tag sanitizer (configurable)
- stop after (shedule stop, without emptying the queue)
	- current
	- current queue
	- timeout
- pause on PC account lock
- schedule stop/pause/app close (with a second seekbar indicating remaining time)
- delete
	- after played
- queued tracks save
- file integrity verifier
- tag charset converter (take a look @ Foobar200's Chacon)
- online tag calculator: gathers info, for each tag lists found options sorted by value's frequency
	- https://www.discogs.com
	- https://last.fm
	- https://musicbrainz.org/
- binary track comparison
- loadable modules to add playlist filters/smart playlists/etc
- keyboard media keys
- manage keywords: { remix, live, cover, location, ... }
	- cover ?= performer != composers && !performers.Any(p => album.authors.contains(p))
- check info contrastanti/mancanti
	- track.disc# > album.discscount
	- album con: stessi nome, artista, tracce, etc. ma ad es. anno diverso
	- tracce senza titolo/artista/album/artwork
	- Artwork data[] != Artwork.MimeType
	- Artwork.Size >= threshold
	- file name == artist(s) - title.ext
- add tags
	- author page (youtube channel)
	- publish URL (youtube/spotify/etc. video/audio URL)
- purge/sanitize tags (to remove custom 3rd party trackers, e.g. Amazon Music, iTunes custom tags, etc.)
- how to organize:
	- lives (might add a tag entry, and specify in config a format to rename the file)
	- covers (new tag: OriginalPerformer)
	- both
- when a media is added, if it's already in the library, [ask to] check for metadata differences
- cache Lyrics
- FluentValidation
- try to optimize for x86 & x64
- UI
	- 2 colori per lista e sidebar: es. grgio medio sidebar, scuro lista cosi sembra più profonda/incavata, elementi lista via di mezzo
- indexed scrollbar with labeled checkpoints based on current sorting, e.g.
	- sorted by artist/title -> alphabet scrollbar
	- sorted by added on date -> years scrollbar
- log criteria to track most used queries and test implementations for best perf in most used scenarios
- servizio per controllare playback dall'esterno del PC (rete locale/globale, autenticazione?)
- https://github.com/tjscience/audion.cscore
- sync col telefono, files compresi
- tray flyout
- commenti sulla canzone/flag per ricordarsi di tagliarla o fare altri interventi
- risultati ricerca canzone -> per ogni traccia che contiene le parole cercate visualizza anche le playlist che la contengono, in modo da poter riprodurre la traccia come inizio della riproduzione di una playlist specifica

- MemoryMappedFile? https://docs.microsoft.com/en-us/dotnet/api/system.io.memorymappedfiles.memorymappedfile#remarks
- Fody per INPC

- benchmark DTOs creation using:
	- separate SELECTs for Entity1, ..., EntityN -> final fusion into DTOs using LINQ-2-Objects
	- JOINed SELECT on all needed Entities (gathering only needed fields) -> Direct DTOs creation

Might help
	- reactive-streams/reactive-streams-dotnet	https://github.com/reactive-streams/reactive-streams-dotnet
	- RxDave/Qactive							https://github.com/RxDave/Qactive
	- http://www.wpf-tutorial.com/